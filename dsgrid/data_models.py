"""Base functionality for all Pydantic data models used in dsgrid"""

from enum import Enum
import json
import os
from pathlib import Path

from pydantic import BaseModel
from semver import VersionInfo

from dsgrid.utils.files import load_data


class DSGBaseModel(BaseModel):
    """Base data model for all dsgrid data models"""

    class Config:
        title = "DSGBaseModel"
        anystr_strip_whitespace = True
        validate_assignment = True
        validate_all = True
        extra = "forbid"
        use_enum_values = False
        arbitrary_types_allowed = True
        allow_population_by_field_name = True

    @classmethod
    def load(cls, filename):
        """Load a data model from a file.
        Temporarily changes to the file's parent directory so that Pydantic
        validators can load relative file paths within the file.

        Parameters
        ----------
        filename : str

        """
        filename = Path(filename)
        base_dir = filename.parent.absolute()
        orig = os.getcwd()
        os.chdir(base_dir)
        try:
            cfg = cls(**load_data(filename.name))
            return cfg

        finally:
            os.chdir(orig)

    @classmethod
    def schema_json(cls, by_alias=True, indent=None) -> str:
        data = cls.schema(by_alias=by_alias)
        return json.dumps(data, indent=indent, cls=ExtendedJSONEncoder)

    @classmethod
    def get_fields_with_extra_attribute(cls, attribute):
        fields = set()
        for f, attrs in cls.__fields__.items():
            if attrs.field_info.extra.get(attribute):
                fields.add(f)
        return fields


class DSGEnum(Enum):
    "dsgrid Enum class"

    def __new__(cls, *args, **kwargs):
        obj = object.__new__(cls)
        obj._value_ = args[0].value
        obj.description = args[0].description
        return obj

    @classmethod
    def format_for_docs(cls):
        """Returns set of formatted enum values for docs."""
        return str({e.value for e in cls}).replace("'", "``")

    @classmethod
    def format_descriptions_for_docs(cls):
        """Returns formatted dict of enum values and descriptions for docs."""
        desc = {}
        for e in cls:
            desc[f"``{e.value}``"] = f"{e.description}"
        return desc


class Value:
    """Class to define a DSGEnum value"""

    def __init__(self, value, description):
        self.value = value
        self.description = description


class ExtendedJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, VersionInfo):
            return str(obj)
        if isinstance(obj, Enum):
            return obj.value

        return json.JSONEncoder.default(self, obj)


def serialize_model(model: DSGBaseModel):
    """Serialize a model to a dict, converting values as needed."""
    # TODO: we should be able to use model.json and custom JSON encoders
    # instead of doing this, at least in most cases.
    return _serialize_model_data(model.dict(by_alias=True))


def serialize_user_model(model: DSGBaseModel):
    """Serialize the user model to a dict, converting values as needed and ignoring fields generated by dsgrid."""
    # TODO: we should be able to use model.json and custom JSON encoders
    # instead of doing this, at least in most cases.
    exclude = type(model).get_fields_with_extra_attribute("dsg_internal")
    return _serialize_model_data(model.dict(by_alias=True, exclude=exclude))


def _serialize_model_data(data: dict):
    for key, val in data.items():
        data[key] = _serialize_model_item(val)
    return data


def _serialize_model_item(val):
    if isinstance(val, Enum):
        return val.value
    if isinstance(val, VersionInfo):
        return str(val)
    if isinstance(val, dict):
        return _serialize_model_data(val)
    if isinstance(val, list):
        return [_serialize_model_item(x) for x in val]
    return val
